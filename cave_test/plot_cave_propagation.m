% This script plots the wideband Rx power and Signal-to-Noise Ratio (SNR) contour plots
% based on BELLHOP grid data generated by the CREATE_GRID_LUT script

% Copyright 2020 Nils Morozs, University of York (nils.morozs@york.ac.uk)
%
% Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
% associated documentation files (the "Software"), to deal in the Software without restriction,
% including without limitation the rights to use, copy, modify, merge, publish, distribute,
% sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
%
% The above copyright notice and this permission notice shall be included in all copies or substantial
% portions of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
% NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
% NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
% OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

% This work was supported by the UK Engineering and Physical Sciences Research Council (EPSRC) 
% through the USMART Project under Grant EP/P017975/1.

%% Calculate Rx power and signal-to-noise ratio (SNR) at every location on a grid

% Specify the CSV file with BELLHOP grid data to be plotted
file_name = 'data/angled_cave_1bend_grid_data.csv';

% Choose the centre frequency and bandwidth in Hz
centre_freq = 24e3;
bandwidth = 1e3;
signal_vs_reverb_time = 10e-3; % widnow for useful signal decoding (the rest is considered reverb)

% Specify the location of the source
source_depth = 10;

% Set source level;
source_txp = 170; % 170 dB re 1 uPa @ 1m

% Specify whether the multipath adds up coherently or incoherently (phase ignored)
coherent_multipath = false;

% Read the CSV file with all data and discard all rows not corresponding to the source depth
csv_contents = csvread(file_name, 1, 0);
csv_data = csv_contents( abs(csv_contents(:, 1)-source_depth) < 1e-3, : );

% If there are no rows, then this source depth is not in the data
if isempty(csv_data)
    error(['Could not find data for this source depth; available source depths: ' num2str(unique(csv_contents(:, 1))')]);
end

% Delete the variable with all unfiltered CSV contents
clear csv_contents;

% Extract unique receiver depths and ranges from the CSV data
rx_depths = unique(csv_data(:, 2));
rx_ranges = unique(csv_data(:, 3));
sound_speed = 1500;

% Create a vector of frequency sampling points used for integrating receiver power across a specified bandwidth
step_size = 1; % 1 Hz step size (needs to be small enough to capture all frequency selective fading)
freq_points = linspace(centre_freq-bandwidth/2, centre_freq+bandwidth/2, ceil(bandwidth/step_size)+1)';
freq_points_kHz = freq_points .* 1e-3;

% For every grid location, calculate Rx signal power
rxp_grid = NaN(numel(rx_ranges), numel(rx_depths));
reverb_grid = NaN(numel(rx_ranges), numel(rx_depths));
for n = 1:numel(rx_ranges)
    for k = 1:numel(rx_depths)
        
        % Find the row in the CSV data corresponding to this location
        row_ind = (k-1)*numel(rx_ranges) + n;
        csv_row = csv_data(row_ind, :);
        
        % Take out the columns with padded zero entries (where amplitude and delay are zero due to variable number of echoes)
        if (rx_ranges(n) > 0) || (rx_depths(k) ~= source_depth)
            first_padded_echo = find( (csv_row(4:3:end-2)==0) & (csv_row(6:3:end)==0), 1, 'first');
            csv_row(4 + 3*(first_padded_echo-1) : end) = [];
        end
        
        % From this row, read the amplitudes, phase shifts and delays of all echoes
        imp_resp{1, k, n}.ampl = 10 .^ ( csv_row(4:3:end-2) ./ 20);
        imp_resp{1, k, n}.phase_shift = csv_row(5:3:end-1);
        imp_resp{1, k, n}.delay = csv_row(6:3:end);
        imp_resp{1, k, n}.num_echoes = numel(imp_resp{1, k, n}.delay);
        
        % Calculate the channel gain and delay from the impulse response
        [ch_gain, ~, ~, reverb_ch_gain] = process_imp_resp(imp_resp{1, k, n}, centre_freq, bandwidth, sound_speed,...
                                        coherent_multipath, signal_vs_reverb_time);

        % Calculate receiver signal power by integrating across the given bandwidth
        rxp_grid(n, k) = source_txp + ch_gain;
        reverb_grid(n, k) = source_txp + reverb_ch_gain;
    end
end

% Calculate signal to reverb in dB
srr_grid = rxp_grid - reverb_grid;

% Load altimetry and bathymetry
load([extractBefore(file_name, '.'), '_bty_ati.mat']);

%% Plot the SNR and Rx power heatmaps

% Plot the SRR heatmap
min_srr = -12;
max_srr = 4;

f = figure; hold on;
f.Renderer='Painters';
h = contourf(rx_ranges, -rx_depths, srr_grid.', min_srr:1:max_srr, 'linestyle', 'none');
colormap(parula(numel(min_srr:2:max_srr)-1));
c = colorbar;
yticks(-max(rx_depths):100:0)
yticklabels(max(rx_depths):-100:0);
caxis([min_srr max_srr]);
% plot(0, -source_depth, 'go', 'linewidth', 2);
axis([-Inf max(rx_ranges) -Inf Inf]);
xlabel('Range, m'); ylabel('Depth, m');
c.Label.String = 'Signal-to-Reverb Ratio, dB';
c.Label.FontSize = 11;
box on; grid on;
% Plot source location and top and bottom of cave
brown_color = [100 70 36]./256;
fill([topbound_x, max(rx_ranges)], [-topbound_y, 0], 0, 'FaceColor', brown_color);
area(bty_x, -bty_y, -max(rx_depths), 'FaceColor', brown_color);
plot(0, -source_depth, 'go', 'linewidth', 2);

% Plot the channel gain heatmap
min_gain = -110;
max_gain = -50;

f = figure; hold on;
f.Renderer='Painters';
h = contourf(rx_ranges, -rx_depths, rxp_grid.' - source_txp, min_gain:2:max_gain, 'linestyle', 'none');
colormap(parula(numel(min_gain:5:max_gain)-1));
c = colorbar;
yticks(-max(rx_depths):100:0)
yticklabels(max(rx_depths):-100:0);
caxis([min_gain max_gain]);
axis([-Inf max(rx_ranges) -Inf Inf]);
xlabel('Range, m'); ylabel('Depth, m');
c.Label.String = 'Channel gain, dB';
c.Label.FontSize = 11;
box on; grid on;
% Plot source location and top and bottom of cave
brown_color = [100 70 36]./256;
fill([topbound_x, max(rx_ranges)], [-topbound_y, 0], 0, 'FaceColor', brown_color);
area(bty_x, -bty_y, -max(rx_depths), 'FaceColor', brown_color);
plot(0, -source_depth, 'go', 'linewidth', 2);